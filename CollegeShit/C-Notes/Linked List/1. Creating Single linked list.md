```c
#include <stdio.h>
#include <stdlib.h>

struct node{
    int data;
    struct node *link;
};

int main(){
    //head pointer to point to first node.
    struct node *head = NULL; //Pointer to struct node.
    head = (struct node *)malloc(sizeof(struct node));
    head -> data = 45;
    head -> link = NULL;

    //current pointer to point to the current node (whether it's second or third or fourth so on....)
    //here current pointer points to the second node
    struct node *current = (struct node *)malloc(sizeof(struct node));
    current -> data = 98;
    current -> link = NULL;

    //linking head node and the current node by storing address of second node in first
    head -> link = current;

    //creating third node by moving the current pointer to act as third not second
    current = (struct node *)malloc(sizeof(struct node));
    current -> data = 3;
    current -> link =NULL;

    //storing third node address in second 
    //head -> link (first node) -> link (second node) = current (third node)
    head -> link -> link = current;

    //creating fourth node by moving current pointer to now act as fourth as previously it did for third
    current = (struct node *)malloc(sizeof(struct node));
    current -> data = 67;
    current -> link = NULL;
    
    //head -> link (first node) -> link (second node) -> link (third node) = current (fourth node)
    head -> link -> link -> link = current;

    return 0;
}
```


---
# 2. TRAVERSING LIST :

Taking another pointer **ptr** to traverse the list.

---

# 1. Counting Number of Nodes  :

```c
void countNodes(struct node *head){
    int count = 0;

    if(head == NULL){
        printf("Linked List is empty");
    }
    struct node *ptr = head;
    while (ptr!=NULL)
    {
        count++;
        ptr = ptr -> link;
    }
    printf("Number of nodes in list: %d", count);
}

int main(){
    countNodes(head); // calling the countNodes function
    printf("\n");
}
```

##### Explanation :
```c
struct node *ptr = head;
```


This line of code is creating a **new pointer** `ptr` and assigning it the value of `head`.

### **What It Does**

- `head` is already pointing to the first node of the linked list.
- `ptr` is now **another pointer** that starts at the same location as `head`.
- This allows `ptr` to traverse the list **without modifying `head`**.

### **Why Is It Needed?**

When you want to **traverse a linked list**, you need a pointer to move through the list **without losing the reference to the first node** (`head`).

---
# 2. Printing the data :

```c
void printList(struct node *head){
    if (head==NULL){
        printf("List is empty");
    }
    struct node *ptr = head;

    printf("List : ");
    while(ptr!=NULL){
        printf("%d ", ptr -> data);
        ptr = ptr -> link;
    }
}

int main(){
	printList(head); //calling the printList function.
}
```

---
![[Screenshot 2025-03-03 at 7.33.01 PM.png]]

---
# Creating list using InsertAtEnd() Function :
```c
#include <stdio.h>
#include <stdlib.h>

struct node {
    int data;
    struct node *link;
};

struct node* insertAtEnd(struct node *ptr, int data){
    struct node *temp = malloc(sizeof(struct node));
    temp->data=data;
    temp->link=NULL;

    ptr->link=temp;
    return temp;
}
int main(){

    //CREATING HEAD NODE
    struct node *head= malloc(sizeof(struct node));
    head->data=56;
    head->link=NULL;

    struct node *ptr=head;
    ptr=insertAtEnd(ptr,89);
    ptr=insertAtEnd(ptr,76);
    ptr=insertAtEnd(ptr,99);

    ptr=head; //to traverse and print the entire linked list from the beginning.
    while(ptr!=NULL){
        printf("%d ",ptr->data);
        ptr = ptr->link;
    }
    return 0;
}
```

---
---
---

# INSERTION:

---

## 1. At End
```c
void insertAtEnd(struct node *head, int data){
    struct node *ptr, *temp;
    temp = (struct node *)malloc(sizeof(struct node));

    temp -> data = data;
    temp -> link = NULL; //Inserting at end

    ptr=head;
    while (ptr -> link!=NULL)
    {
     ptr = ptr->link;   
    }
    ptr->link=temp;
    
}

int main(){
    //Inserting at end
    insertAtEnd(head,33);
    printf("After inserting new node at end -- ");
    printList(head);
    printf("\n");
}
```

---
## 2. At Beginning

### Method 1: 
```c
struct node* insertAtBeg(struct node *head, int data){
    struct node *ptr = malloc(sizeof(struct node));
    ptr->data=data;
    ptr->link=head; //Point new node to old head
    
    head=ptr; //Update head to point to new node
    return head;//return the new head
}

int main(){
    //Inserting at beginning
    head = insertAtBeg(head,44); 
    printf("After inserting new node at Beginning -- ");
    printList(head);
}
```

##### Explanation :
```c
head = insertAtBeg(head, 44);
```
- Calls the function insertAtBeg(head, 44), which creates a new node with data = 44 and inserts it at the start.
- The function returns the new head of the list.
- The head pointer is updated to point to the new node
- **`head`** inside **`insertAtBeg(head,44)`** is **passed by value** (local to the function) and not by reference , if we don't return it then it will only update the head contained inside it not the head in main.
### Method 2:
```c
//PASSING BY REFERENCE (HEAD)
void insertAtBeg(struct node **head, int data){
    struct node *ptr = malloc(sizeof(struct node));
    ptr->data=data;
    ptr->link=NULL;
    
    ptr->link=*head; //Point new node to current head
    *head=ptr; //Update head to point to new node
}
int main(){
    insertAtBeg(&head,44); //passing by refernce
    printf("After inserting new node at Beginfsfning -- ");
    printList(head);
}
```

##### Explanation :
- Instead of passing head by value, we now **pass it by reference (&head).**
- This allows the function to directly modify the head pointer in main(), **without needing to return it**

Insert at beginning simple code 
```C
void insBeg(int value) {
	struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
	newNode->data = value;
	newNode->next = NULL;
	head = newNode;
}
```

-----
----
### TO STUDY:

# Singly Linked List with `void` methods
## Step By Step

### Node Structure and HEAD Creation 
```c
#include <stdio.h> // for standard input output
#include <stdlib.h> // for dynamic memory allocation

// Node definition
struct Node {
    int data;
    struct Node* next; // struct type pointer for nodes
};
```

### Function for Node Creation
```C
// Helper function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}
```

### Insertion at Beginning and END
```C
// Insert at beginning
void insBeg(int value) { 
	// creating node
    struct Node* newNode = createNode(value);
    newNode->next = head;
    head = newNode;
}

// Insert at end
void insEnd(int value) {
    // creating Node
    struct Node* newNode = createNode(value);

    // checking if list is empty then make the newNode head.
    // else traverse the list and put the node in end.
    if (head == NULL) {
        head = newNode;
    } else { 
        struct Node* temp = head;
        while (temp->next != NULL) {
            temp = temp->next;
        }       
        temp->next = newNode;
    }
}
```

### insertion After a node
**Simple Logic:**
- Traverse the list until `temp->data` matches the `target` value.
- At this point, `temp` points to the node that contains the `target`.
- Create a new node (`newNode`) and set its `next` pointer to `temp->next`.
- Finally, update `temp->next` to point to `newNode`.
 
```C
// Insert after a target node
void insAfter(int target, int value) {
    // if list is empty, simply exit the function
    if (head == NULL) return;

    // else, traverse the list till target is found or list is fully traversed.
    struct Node* temp = head;
    while (temp != NULL && temp->data != target) {
        temp = temp->next;
    }

    // if list was traversed and target not found.
    if (temp == NULL) {
        printf("Target not found in the list.\n");
        return;
    }

    // if target was found 
    struct Node* newNode = createNode(value);
    newNode->next = temp->next;
    temp->next = newNode;
}
```

### Insertion Before a node
**Simple logic:**
- Traverse the list until `temp->next->data` matches the `target` value.
- At this point, `temp` points to the node just before the target node.
- Create a new node (`newNode`) and set its `next` pointer to `temp->next`.
- Update `temp->next` to point to `newNode`.

```C
// Insert before a target node
void insBefore(int target, int value) {
    // exit if list empty
    if (head == NULL) return;

    // SPECIAL CASE: if you want to insert before head node.
    if (head->data == target) {
        struct Node* newNode = createNode(value);
        newNode->next = head;
        head = newNode;
        return;
    }

    // traverse list till target found or end is reached.
    struct Node* temp = head;
    while (temp->next != NULL && temp->next->data != target) {
        temp = temp->next;
    }

    // if target not found i.e. reached end
    if (temp->next == NULL) {
        printf("Target not found in the list.\n");
        return;
    }

    // insert node
    struct Node* newNode = createNode(value);
    newNode->next = temp->next;
    temp->next = newNode;
}
```

### Deletion at Beg
```C
// Delete from beginning
void delBeg() {
    // exit if list empty.
    if (head == NULL) return;

    // put head in temp and move head to next, free(temp)
    struct Node* temp = head;
    head = head->next;
    free(temp);
}
```

### Deletion at End
**Simple Logic:**
- Traverse the list until `temp->next->next` becomes `NULL`.
- At this point, `temp` points to the **second last node** in the list.
- Free the memory allocated to `temp->next`, which is the **last node**.
- Set `temp->next` to `NULL` to mark the new end of the list.

```C
// Delete from end
void delEnd() {
    // exit if list empty
    if (head == NULL) return;

    // SPECIAL CASE: if only 1 node in list.
    if (head->next == NULL) {
        free(head);
        head = NULL;
        return;
    }

    // traverse till end.
    // temp points to second last node
    // free  temp->next, which is last node
    struct Node* temp = head;
    while (temp->next->next != NULL) {
        temp = temp->next;
    }
    free(temp->next);
    temp->next = NULL;
}
```

### Deletion after a node
**Simple Logic:**
- Traverse the list until `temp->data` matches the `target` value.
- At this point, `temp` points to the node **before** the one to be deleted.
- Check if `temp->next` is `NULL` — if so, there's no node to delete after `target`.
- Otherwise, store the node to be deleted in a temporary pointer (`temp2`).
- Update `temp->next` to `temp->next->next`, bypassing the node to be deleted.
- Free the memory allocated to `temp2`.

```C
// Delete after a given node
void delAfter(int target) {

    // traverse the list till end or target found
    struct Node* temp = head;
    while (temp != NULL && temp->data != target) {
        temp = temp->next;
    }

    if (temp == NULL) {
        printf("Target not found\n");
        return;
    }

    // SPECIAL CASE: if target is last node.
    if (temp->next == NULL) {
        printf("Cannot delete after last node!\n");
        return;
    }

    // create temp2 to hold the node which is to be deleted.
    // point temp->next to temp2->next
    struct Node* temp2 = temp->next;
    temp->next = temp->next->next;
    free(temp2);
}
```

### Delete before a node
**Simple Logic:**
- Traverse the list until `temp->next->next->data` matches the `target` value.
- At this point, `temp->next` points to the node **before the target**, and `temp` points to the node **before the one to be deleted**.
- Store the node to be deleted (`temp->next`) in a temporary pointer.
- Update `temp->next` to `temp->next->next`, effectively removing the node before the target.
- Free the memory allocated to the deleted node.

```C
// Delete before a given node
void delBefore(int target) {
    // if only one element in node
    if (head == NULL || head->next == NULL) {
        printf("List too short to delete before target.\n");
        return;
    }

    // SPECIAL CASE: if the head is target, cannot delete before head
    if (head->data == target) {
        printf("No node exists before the head.\n");
        return;
    }

    // SPECIAL CASE: if target is second element i.e. delete head.
    if (head->next->data == target) {
        struct Node* temp = head;
        head = head->next;
        free(temp);
        return;
    }

    // traverse list till end or till target found
    struct Node* temp = head;
    while (temp->next->next != NULL && temp->next->next->data != target) {
        temp = temp->next;
    }

    // if no target in list
    if (temp->next->next == NULL) {
        printf("Target not found or no node exists before it.\n");
        return;
    }

    // create temp2 to point at temp->next
    // the struture is: temp -> temp2 -> target
    // free temp2
    struct Node* temp2 = temp->next;
    temp->next = temp->next->next;
    free(temp2);
}
```

### Traversal and main method
```c

// Display the list
void traverseList() {
    if (head == NULL) {
        printf("The list is empty.\n");
        return;
    }

    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

void Insert() {
    insBeg(80);
    insBeg(30); 
    insBeg(20); 
    insBeg(10); 
    insAfter(20, 25); 
    insEnd(40); 
    insBefore(40, 35); 
    traverseList();
}

void Delete() {
    delBeg(); 
    delEnd();
    traverseList(); 
    delAfter(20);
    delBefore(80);
    traverseList();
}


int main() {
    Insert();
    Delete();
    return 0;
}
```

## Complete Code
```C
#include <stdio.h>
#include <stdlib.h>

// Node definition
struct Node {
    int data;
    struct Node* next;
};

// Global HEAD
struct Node* head = NULL;

// Helper function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// Insert at beginning
void insBeg(int value) { 
    // creating node
    struct Node* newNode = createNode(value);
    newNode->next = head;
    head = newNode;
}

// Insert at end
void insEnd(int value) {
    // creating Node
    struct Node* newNode = createNode(value);

    // checking if list is empty then make the newNode head.
    // else traverse the list and put the node in end.
    if (head == NULL) {
        head = newNode;
    } else { 
        struct Node* temp = head;
        while (temp->next != NULL) {
            temp = temp->next;
        }       
        temp->next = newNode;
    }
}

// Insert after a target node
void insAfter(int target, int value) {
    // if list is empty, simply exit the function
    if (head == NULL) return;

    // else, traverse the list till target is found or list is fully traversed.
    struct Node* temp = head;
    while (temp != NULL && temp->data != target) {
        temp = temp->next;
    }

    // if list was traverse and target not found.
    if (temp == NULL) {
        printf("Target not found in the list.\n");
        return;
    }

    // if target was found 
    struct Node* newNode = createNode(value);
    newNode->next = temp->next;
    temp->next = newNode;
}

// Insert before a target node
void insBefore(int target, int value) {
    // exit if list empty
    if (head == NULL) return;

    // SPECIAL CASE: if you want to insert before head node.
    if (head->data == target) {
        struct Node* newNode = createNode(value);
        newNode->next = head;
        head = newNode;
        return;
    }

    // traverse list till target found or end is reached.
    struct Node* temp = head;
    while (temp->next != NULL && temp->next->data != target) {
        temp = temp->next;
    }

    // if target not found i.e. reached end
    if (temp->next == NULL) {
        printf("Target not found in the list.\n");
        return;
    }

    // insert node
    struct Node* newNode = createNode(value);
    newNode->next = temp->next;
    temp->next = newNode;
}

// Delete from beginning
void delBeg() {
    // exit if list empty.
    if (head == NULL) return;

    // put head in temp and move head to next, free(temp)
    struct Node* temp = head;
    head = head->next;
    free(temp);
}

// Delete from end
void delEnd() {
    // exit if list empty
    if (head == NULL) return;

    // SPECIAL CASE: if only 1 node in list.
    if (head->next == NULL) {
        free(head);
        head = NULL;
        return;
    }

    // traverse till end.
    // temp points to second last node
    // free  temp->next, which is last node
    struct Node* temp = head;
    while (temp->next->next != NULL) {
        temp = temp->next;
    }
    free(temp->next);
    temp->next = NULL;
}

// Delete after a given node
void delAfter(int target) {

    // traverse the list till end or target found
    struct Node* temp = head;
    while (temp != NULL && temp->data != target) {
        temp = temp->next;
    }

    if (temp == NULL) {
        printf("Target not found\n");
        return;
    }

    // SPECIAL CASE: if target is last node.
    if (temp->next == NULL) {
        printf("Cannot delete after last node!\n");
        return;
    }

    // create temp2 to hold the node which is to be deleted.
    // point temp->next to temp2->next
    struct Node* temp2 = temp->next;
    temp->next = temp->next->next;
    free(temp2);
}

// Delete before a given node
void delBefore(int target) {
    // if only one element in node
    if (head == NULL || head->next == NULL) {
        printf("List too short to delete before target.\n");
        return;
    }

    // SPECIAL CASE: if the head is target, cannot delete before head
    if (head->data == target) {
        printf("No node exists before the head.\n");
        return;
    }

    // SPECIAL CASE: if target is second element i.e. delete head.
    if (head->next->data == target) {
        struct Node* temp = head;
        head = head->next;
        free(temp);
        return;
    }

    // traverse list till end or till target found
    struct Node* temp = head;
    while (temp->next->next != NULL && temp->next->next->data != target) {
        temp = temp->next;
    }

    // if no target in list
    if (temp->next->next == NULL) {
        printf("Target not found or no node exists before it.\n");
        return;
    }

    // create temp2 to point at temp->next
    // the struture is: temp -> temp2 -> target
    // free temp2
    struct Node* temp2 = temp->next;
    temp->next = temp->next->next;
    free(temp2);
}

// Display the list
void traverseList() {
    if (head == NULL) {
        printf("The list is empty.\n");
        return;
    }

    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

//count nodes and return middle element
 void countNodes(struct Node* head) {
    int count = 0;

    if (head == NULL) {
        printf("Linked List is empty\n");
        return;
    }

    // First pass: count total nodes
    struct Node* ptr = head;
    while (ptr != NULL) {
        count++;
        ptr = ptr->next;
    }

    printf("Number of nodes in list: %d\n", count);

    // Second pass: find middle (second middle if even)
    int midIndex = count / 2;
    ptr = head;
    for (int i = 0; i < midIndex; i++) {
        ptr = ptr->next;
    }

    printf("Middle node data: %d\n", ptr->data);
}

void Insert() {
    insBeg(80);
    insBeg(30); 
    insBeg(20); 
    insBeg(10); 
    insAfter(20, 25); 
    insEnd(40); 
    insBefore(40, 35); 
    traverseList();
    countNodes(head);
}

void Delete() {
    delBeg(); 
    delEnd();
    traverseList(); 
    delAfter(20);
    delBefore(80);
    traverseList();
    countNodes(head);
}


int main() {
    Insert();
    Delete();
    return 0;
}

```

## Circular Linked List
```c
#include <stdio.h>
#include <stdlib.h>

// Node definition
struct Node {
    int data;
    struct Node* next;
};

// Global HEAD
struct Node* head = NULL;

// Helper function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// Insert at beginning
void insBeg(int value) {
    struct Node* newNode = createNode(value);

    if (head == NULL) {
        head = newNode;
        newNode->next = head;
    } else {
        struct Node* temp = head;
        while (temp->next != head)
            temp = temp->next;

        newNode->next = head;
        temp->next = newNode;
        head = newNode;
    }
}

// Insert at end
void insEnd(int value) {
    struct Node* newNode = createNode(value);

    if (head == NULL) {
        head = newNode;
        newNode->next = head;
    } else {
        struct Node* temp = head;
        while (temp->next != head)
            temp = temp->next;

        temp->next = newNode;
        newNode->next = head;
    }
}

// Insert after a target node
void insAfter(int target, int value) {
    if (head == NULL) return;

    struct Node* temp = head;
    do {
        if (temp->data == target) {
            struct Node* newNode = createNode(value);
            newNode->next = temp->next;
            temp->next = newNode;
            return;
        }
        temp = temp->next;
    } while (temp != head);

    printf("Target not found in the list.\n");
}

// Insert before a target node
void insBefore(int target, int value) {
    if (head == NULL) return;

    struct Node* newNode = createNode(value);

    // Special case: insert before head
    if (head->data == target) {
        struct Node* temp = head;
        while (temp->next != head)
            temp = temp->next;

        newNode->next = head;
        temp->next = newNode;
        head = newNode;
        return;
    }

    struct Node* temp = head;
    do {
        if (temp->next->data == target) {
            newNode->next = temp->next;
            temp->next = newNode;
            return;
        }
        temp = temp->next;
    } while (temp != head);

    printf("Target not found in the list.\n");
}

// Delete from beginning
void delBeg() {
    if (head == NULL) return;

    struct Node* temp = head;

    // Single node case
    if (head->next == head) {
        free(head);
        head = NULL;
        return;
    }

    struct Node* last = head;
    while (last->next != head)
        last = last->next;

    head = head->next;
    last->next = head;
    free(temp);
}

// Delete from end
void delEnd() {
    if (head == NULL) return;

    // Single node case
    if (head->next == head) {
        free(head);
        head = NULL;
        return;
    }

    struct Node* temp = head;
    while (temp->next->next != head)
        temp = temp->next;

    struct Node* last = temp->next;
    temp->next = head;
    free(last);
}

// Delete after a given node
void delAfter(int target) {
    if (head == NULL) return;

    struct Node* temp = head;
    do {
        if (temp->data == target) {
            struct Node* delNode = temp->next;

            // Special case: only one node
            if (delNode == head && head->next == head) {
                printf("Cannot delete after the only node.\n");
                return;
            }

            // Special case: delete head
            if (delNode == head)
                head = head->next;

            temp->next = delNode->next;
            free(delNode);
            return;
        }
        temp = temp->next;
    } while (temp != head);

    printf("Target not found\n");
}

// Delete before a given node
void delBefore(int target) {
    if (head == NULL || head->next == head) {
        printf("List too short to delete before target.\n");
        return;
    }

    struct Node* temp = head;
    struct Node* prev = NULL;
    struct Node* beforePrev = NULL;

    do {
        if (temp->next != NULL && temp->next->data == target) {
            if (prev == NULL) {
                // Delete head
                struct Node* last = head;
                while (last->next != head)
                    last = last->next;
                struct Node* del = head;
                head = head->next;
                last->next = head;
                free(del);
            } else {
                prev->next = temp->next;
                free(temp);
            }
            return;
        }
        beforePrev = prev;
        prev = temp;
        temp = temp->next;
    } while (temp != head);

    printf("Target not found or no node exists before it.\n");
}

// Display the list (circular-safe)
void traverseList() {
    if (head == NULL) {
        printf("The list is empty.\n");
        return;
    }

    struct Node* temp = head;
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("(back to head)\n");
}

// Insert operations
void Insert() {
    insBeg(80);
    insBeg(30); 
    insBeg(20); 
    insBeg(10); 
    insAfter(20, 25); 
    insEnd(40); 
    insBefore(40, 35); 
    traverseList();
}

// Delete operations
void Delete() {
    delBeg(); 
    delEnd();
    traverseList(); 
    delAfter(20);
    delBefore(80);
    traverseList();
}

// Main function
int main() {
    Insert();
    Delete();
    return 0;
}

```

### Routine (Function) to Convert a Singly Linked List to a Circular Linked List in C
```c
void convertToCircular() {
    if (head == NULL) return;  // Empty list

    struct Node* temp = head;
    while (temp->next != NULL) {
        temp = temp->next;
    }

    temp->next = head;  // Make last node point to head
}
```

## Explanation

- `temp = head;` → start from the head.
    
- `while (temp->next != NULL)` → traverse till the last node.
    
- `temp->next = head;` → make the last node's `next` point to `head`, forming a **circular link**.

Assuming this is your list:

```c
insBeg(30);
insBeg(20);
insBeg(10);
```

Now call:

```c
convertToCircular();
```

The list becomes:
```css
10 → 20 → 30 → (back to 10)

```

---
---

### ✅ Step 1: Detect Cycle (Using Floyd’s Cycle-Finding Algorithm)

1. Initialize two pointers:
    
    - `slow = head`
        
    - `fast = head`
        
2. Move the pointers:
    
    - `slow = slow->next`
        
    - `fast = fast->next->next`
        
3. Repeat step 2 until:
    
    - `fast == NULL` or `fast->next == NULL` → **No cycle**
        
    - `slow == fast` → **Cycle detected**
        

---

### ✅ Step 2: Find the Start of the Cycle

4. After detecting the cycle, reset `slow = head`.
    
5. Move both `slow` and `fast` one step at a time:
    
    - `slow = slow->next`
        
    - `fast = fast->next`
        
6. The node where they meet again is the **start of the cycle**.
    

---

### ✅ Step 3: Remove the Cycle

7. To remove the cycle:
    
    - Traverse from the meeting point (`fast`) until `fast->next == slow`.
        
    - Set `fast->next = NULL`.
## Actual Answer: Using Floyd's Cycle Detection Algorithm - O(n) Time and O(1) Space
### 1. Detect Loop in Linked List using Floyd's Cycle Detection Algorithm.

- Use two pointers, ****slow**** and ****fast**** and initialize them with the ****head**** of the linked list.
- Move the ****fast**** pointer ****forward**** by two nodes and move the ****slow**** pointer forward by ****one**** node.
- If the ****slow**** and ****fast**** pointer points to the ****same node****, ****loop**** is found.
- Else if the ****fast**** pointer reaches ****NULL****, then ****no loop**** is found.
- Else ****repeat**** the above steps till we reach the ****end**** of the linked list or a ****loop**** is found.
### 2. Remove Loop in Linked List (if any):

The idea is similar to finding the [starting node of Loop in a Linked List](https://www.geeksforgeeks.org/find-first-node-of-loop-in-a-linked-list/). For this, we will point the ****slow**** pointer to ****head**** node and ****fast**** pointer will ****remain**** at its position. Both slow and fast pointers move ****one step**** ahead until ****fast->next**** is not equals to ****slow->next****. When ****slow->next**** equals to ****fast->next**** we can easily point ****fast->next to NULL**** to remove the loop.